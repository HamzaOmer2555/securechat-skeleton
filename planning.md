Phase 0: Environment Setup & Git WorkflowGoal: Establish the development environment and ensure the GitHub workflow is ready (20% of grade).Repository Initialization:Fork the securechat-skeleton to your GitHub account1.Clone the fork to your local Ubuntu machine.Crucial: Create a .gitignore immediately to ensure you never commit secrets (keys, salts, .env)2.Virtual Environment & Dependencies:Create a Python virtual environment: python3 -m venv .venv.Activate it: source .venv/bin/activate.Install dependencies: pip install -r requirements.txt (likely includes cryptography, pydantic, mysql-connector-python).Database Setup (Docker on Ubuntu):Since you use Ubuntu, use Docker to spin up the MySQL instance as suggested in the README.Run the Docker command provided in the README to set up the container with persistence.Verify connection: docker ps to check if it's running.GitHub Hygiene Strategy:Plan to commit after each phase below. The rubric requires $>10$ meaningful commits3.Commit format: [Feature] Implemented AES wrapper or [Fix] Resolved padding error.

Phase 1: Cryptographic Primitives (The "Engine" Room)Goal: Implement the math/logic wrappers in app/crypto/ before writing any network code.AES Implementation (app/crypto/aes.py):Implement encrypt(key, plaintext) and decrypt(key, ciphertext).Requirement: Use AES-128 in CBC or ECB mode (verify strictly if ECB or CBC is required, PDF mentions block cipher + PKCS#7)4.Padding: Implement PKCS#7 padding/unpadding logic5.Hashing & Signing (app/crypto/sign.py):Implement SHA-256 hashing wrapper.Implement RSA Key Generation (for the CA and clients).Implement sign(private_key, data) and verify(public_key, signature, data) using RSA-SHA2566.Diffie-Hellman Logic (app/crypto/dh.py):Implement the generation of public parameters ($p, g$) and private/public keys ($a, A$).Implement the shared secret calculation: $K_s = B^a \mod p$7.Implement the Key Derivation Function (KDF): $K = \text{Trunc}_{16}(\text{SHA256}(K_s))$8.

Phase 2: PKI Infrastructure (The Trust Model)Goal: Build the Certificate Authority and verification logic.CA Script (scripts/gen_ca.py):Write the script to generate a root private key and a self-signed X.509 certificate9.Save these to certs/ (ensure this folder is ignored by Git).Certificate Issuance (scripts/gen_cert.py):Write the script to generate keys for the Server and Client.Create Certificate Signing Requests (CSR) and have the Root CA sign them.Output: server.crt, server.key, client.crt, client.key.Certificate Validation (app/crypto/pki.py):Implement strict validation logic:Check signature against Root CA10.Check expiration (NotBefore / NotAfter)11.Check Common Name (CN) matches the expected host12.

Phase 3: Networking & Control Plane (Connection)Goal: Establish a TCP connection and exchange "Hello" messages with certificates.Protocol Definitions (app/common/protocol.py):Define Pydantic models for Hello, Register, Login, DH_Exchange, Message, and Receipt based on the JSON formats defined in the PDF 13.Server Setup (app/server.py):Create a raw TCP socket (bind/listen).Implement the LISTEN loop.Load the Server Certificate and Private Key on boot.Client Setup (app/client.py):Load Client Certificate and Private Key on boot.Connect to the server.The Handshake (Part 1):Client: Sends Hello (Client Cert + Nonce).Server: Receives Hello, validates Client Cert14, sends Server Hello (Server Cert + Nonce).Client: Receives Server Hello, validates Server Cert.Milestone: Both sides print "Secure Connection Established" (or similar).

Phase 4: Authentication (Register/Login)Goal: Securely handle user credentials using the DB and encryption.Database Layer (app/storage/db.py):Implement init_db to create the users table15.Implement add_user(email, username, salt, pwd_hash) and get_user(username).Ephemeral Key Exchange:Before sending credentials, run a temporary DH exchange to get an initial AES key16.Registration Flow:Client: Encrypt {email, user, password} with AES key. Send register payload.Server: Decrypt. Generate 16-byte Salt. Hash password: SHA256(salt || password). Store in DB 17.Login Flow:Client: Encrypt login details. Send login payload.Server: Decrypt. Retrieve user salt. Re-hash input password. Compare with DB hash. Send Auth Success/Fail.

Phase 5: Session Key Agreement (Post-Auth)Goal: Establish the actual session key for the chat.DH Protocol Implementation:Client: Send DH Public Key ($A$).Server: Send DH Public Key ($B$).Both: specific calculate Shared Secret $K_s$ and derive Session Key $K$18.Note: This key $K$ is now used for all subsequent chat messages.

Phase 6: The Data Plane (Secure Chat)Goal: Send/Receive encrypted, signed messages with replay protection.Message Construction (Sender):Get input.Encrypt ciphertext (AES with Session Key $K$).Generate Timestamp and Sequence Number (SeqNo).Create Signature: Sign(SHA256(seqno || ts || ct)) 19.Send JSON payload.Message Processing (Receiver):Receive JSON.Verify 1: Is seqno > last_seqno? (Replay check) 20.Verify 2: Verify RSA signature using peer's public key21.Decrypt: AES decrypt ciphertext + unpad.Display message.

hase 7: Non-Repudiation (Transcripts)Goal: Evidence generation.Transcript Logger (app/storage/transcript.py):Implement an append-only log in memory or file.Format: seqno | ts | ct | sig | peer-fingerprint22.Session Receipt (On Close):When typing /quit:Concatenate all transcript lines.Compute SHA256(Transcript).Sign the hash.Export the SessionReceipt JSON23.

Phase 8: Testing & Evidence CollectionGoal: Create the artifacts required for grading (10% of grade).Wireshark Capture:Run Wireshark on loopback (lo) interface.Filter for the specific port (e.g., tcp.port == 8080).Capture a full session. Validate that no plaintext is visible24.Negative Testing:Bad Cert: Generate a cert signed by a different CA key. Try to connect. Ensure BAD_CERT error occurs.Tampering: Hardcode a bit-flip in the ciphertext in client.py right before sending. Ensure Server logs SIG_FAIL25.Replay: Hardcode the client to resend a previous JSON packet. Ensure Server logs REPLAY26.

Phase 9: Documentation & SubmissionGoal: Final polish.Reports:Draft RollNumber-FullName-Report-A02.docx (Implementation details).Draft RollNumber-FullName-TestReport-A02.docx (Screenshots of Wireshark, error logs, and receipt verification).README.md:Update the README with specific instructions on how to run your code on Ubuntu (mention the venv and docker steps).Final Check:Ensure env.example is present.Ensure NO secrets are in the repo.Zip the repo + SQL dump.